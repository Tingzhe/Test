This is an org-mode document.  Pressing 'tab' with the cursor over a line
beginning with '*' will expand or collapse an outline heading.

* About

This document tracks all edits that are made within the inc/ and lib/
folders.  For each edit, we attempt to explain what was done, and why.

The list of finding should be re-generatable via the following command:
    egrep -R '(transaction)|(TM_SAFE_ATT)' inc/ lib/ 

* Edits discovered when working on std::list
** Add transaction_safe attribute to methods of _List_node_base 
*** Names of files affected
inc/stdinc/bits/stl_list.h
*** Names of functions marked
swap, _M_transfer, _M_reverse, _M_hook, and _M_unhook
*** Line numbers of annotations
84, 88, 93, 97, 101
*** Rationale
These 5 functions, which are common to all instantiations of the std::list
template, are not visible in the stl_list.h file, but instead are compiled
when lib/libstdc++-v3/c++98/list.cc is compiled.  The implementations do
nothing unsafe, and thus marking the declarations in the stl_list.h header
suffices to both (a) ensure that the compilation of list.cc produces regular
and transactional versions, and (b) ensure that the compiler knows that calls
to these functions, made within methods of std::list, should not prevent
those std::list methods from being used within transactions.

** Add transaction_safe attribute to __throw_bad_alloc
*** Names of files affected
inc/stding/bits/functexcept.h
*** Names of functions marked
__throw_bad_alloc
*** Line numbers of annotations
51
*** Rationale
The __throw_bad_alloc() function must be safe, in order for std::list to be
safe.  The implementation, in lib/libstdc++-v3/c++11/functexcept.cc, does
nothing unsafe, so marking the function safe in a header resolves all issues.

** Provide a pure wrapper for __builtin_abort()
*** Names of files affected
inc/stdinc/bits/stl_list.h
*** Line numbers
64, 1710
*** Rationale
__builtin_abort should be transaction_safe, as the specification is moving
toward stating that an abort ought to simply terminate the transaction, and
the program.  By making a transaction_pure wrapper, and then replacing a
single call to __builtin_abort with a call to wrapped_abort(), we can get
the desired effect (at least for STM).
*** Open Issues: 
How ought this to work for HTM?

* Edits discovered when working on std::deque
** Mark __throw_length_error as transaction_pure
*** Names of files affected
inc/stding/bits/functexcept.h
*** Names of functions marked
__throw_length_error
*** Line numbers of annotations
89
*** Rationale
In lib/libstdc++-v3/c++11/functexcept.cc, __throw_length_error constructs an
exception object and throws it.  However, the exception object has a string
member, which is constructed from a const char* parameter.  Technically, all
of this should "just work" in HTM, and in STM, the refcounts within
std::string should not be a problem, because the call chain between
invocation and return of __throw_length_error does not interact with any
data that is accessed transactionally.  Thus synchronization via locks and
volatiles/atomics is OK.
*** Open Issues:
This is a hack.  The right answer is to either (a) fix std::string, or (b)
use const char* fields, instead of strings, within logic_error exception
objects.

* Edits discovered when working on std::string
** TODO this work should be un-done, and then re-done properly
inc/stdinc/bits/basic_string.tcc:      __attribute__((transaction_safe))
inc/stdinc/bits/basic_string.tcc:      __attribute__((transaction_safe))

* Edits discovered when working on std::vector
** TODO these two edits need explanation / documentation
inc/stdinc/bits/stl_algobase.h:    TM_SAFE_ATT
inc/stdinc/bits/stl_vector.h:    TM_SAFE_ATT
